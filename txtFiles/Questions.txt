In an unweighted undirected connected graph having V vertices and E edges, define the average hop distance to be X/Y, where:
	- X = the sum of the shortest path distances from every vertex to every other vertex
	- Y = V * (V - 1) is the number of pair vertices
Since the graph is connected, we have E >= V - 1. Describe an O(VE) time algorithm to compute the average hop distance.

Answer: 
	1. Let X = 0
	2. for (i = 0; i < V; i++)
		Run BFS from vertex i.
		for (j = 0; j < V; j++)
			X = X + level[j]
	3. Y = V*(V-1)
    4. Avg. hop distance = X/Y

	Each BFS execution needs O(V+E) time. Updating X for each BFS execution needs O(V) time. There are V many BFS executions. Hence, complexity is LaTeX: O(VE).

=====

Let G be a directed graph having V vertices and E edges. A transitive closure is a matrix M such that M[i][j] is true if there is a path from vertex v_i to vertex v_j, else M[i][j] is false. How will you use DFS to compute the matrix  M in O(V^2+VE) time?

Answer: 
	1. Create a two-dimensional array M of dimensions V by V
	2. for (i = 0; i < V; i++)
		Run DFS from vertex i.
        for (j = 0; j < V; j++)
			if level[j] equals infinity, then set M[i][j] = false,
			else set M[i][j] = true

	Each DFS execution needs O(V+E) time. Updating M for each DFS execution needs O(V) time. There are V many DFS executions. Hence, complexity is O(V⋅(V+E)) = O(V^2+V⋅E ).

=====

A component in an undirected graph is a subset of vertices (and edges) such that there is a path between every pair of vertices. For example, the 3 components of the following graph are {LaTeX: {v_{0}, v_{4}, v_{5}, v_{6}} v 0 , v 4 , v 5 , v 6 }; {LaTeX: {v_1, v_2, v_3} v 1 , v 2 , v 3 }; and {LaTeX: {v_7} v 7 }. 
Using Breadth-First Search (don't use DFS) as the main idea, give an O(V+E) detailed pseudo-code to find the number of components of an undirected graph with V vertices and E edges.
	- The vertices are labeled {0, 1, 2, ..., V - 1}
	- The graph is given in an adjacency-list form

Answer: 
	
    - Set all entries of level[] to LaTeX: \infty ∞
    - numComponents = 0
    - for (int i = 0; i <V; i++)
        - if (level[i] == LaTeX: \infty ∞ )
            - numComponents ++
            - level[i] = 0 and enqueue i
            - while (queue has at least one vertex)
                - u = dequeue()
                - for every outgoing edge (u,v) of u
                    - if (level[v] == LaTeX: \infty ∞ )
                        - enqueue v
                        - level[v] = level[u] + 1
    - output numComponents

=====



A repeating substring of a string LaTeX: X X is a substring that occurs at least twice in LaTeX: X X . For example, if LaTeX: X X = abcdbce, then bc is a repeating substring in X, whereas ab is not.

A longest repeating substring is a repeating substring which is also the longest (there may be more than one). For example, if LaTeX: X X = cabbcabca, then cab and bca are both longest repeating substrings.

Your task is to find such a longest repeating substring (or detect there is none). Suppose you are given a suffix trie of LaTeX: X X . Assume the following:

    At any node in the trie, you can traverse to a child node or parent node in LaTeX: O(1) O ( 1 ) time.
    For any node, you can find the number of leaves in the subtree of that node in LaTeX: O(1) O ( 1 ) time.
    At each node, you can read the label of the edge to its parent in LaTeX: O(1) O ( 1 ) time.
    The number of nodes in the trie is LaTeX: m > n m > n .

Describe an O(m) time algorithm to compute a longest repeating substring using the suffix trie.

Answer: 
The main idea is to find the deepest node which has at least two leaves in its subtree. If a node has at least two leaves, then the string formed by concatenating the edge labels from root to the node prefixes at least two suffixes (corresponding to the two leaves). The deepest node gives you the longest of such repeating prefixes, which is essentially the longest repeating substring.

More specifically,

    -Initially, answerNode = null and longestRepeatLength = 0
    -Start at the root node and execute a BFS
    -While executing BFS, when an edge from u to v is relaxed, do the following:
        -level[v] = level[u] + 1 and enqueue v
        -if (v has more than one children in its subtree AND level[v] > longestRepeatLength)
            -longestRepeatLength = level[v]
            -answerNode = v
    -Initialize LRS = ""
    -Start at node v and traverse up to the root node and concatenate the edge character to LRS
    -Reverse LRS, which gives the the longest repeating substring
